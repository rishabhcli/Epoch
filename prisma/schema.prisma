// Epoch Pod - Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTH MODELS
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  role          UserRole  @default(USER)

  // Preferences (stored as JSON)
  preferences   Json      @default("{\"topics\":[],\"emailCadence\":\"weekly\",\"voiceConfig\":{\"provider\":\"openai\",\"voiceId\":\"alloy\",\"model\":\"tts-1-hd\",\"speed\":1.0},\"episodeDuration\":1200,\"includeTranscripts\":true,\"privateFeedEnabled\":false}")

  // Private RSS feed token
  feedToken     String?   @unique

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  emailVerified DateTime?

  // Relations
  accounts      Account[]
  sessions      Session[]
  episodes      Episode[]
  subscription  Subscription?
  debateVotes   DebateVote[]
  userJourneys  UserJourney[]

  @@index([email])
  @@index([feedToken])
}

enum UserRole {
  USER
  ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// EPISODE MODELS
// ============================================================================

model Episode {
  id          String         @id @default(cuid())
  guid        String         @unique @default(cuid())

  // Basic info
  title       String
  subtitle    String?
  description String?

  // Content
  topic       String
  era         String?
  outline     Json?          // Stores Outline schema
  script      Json?          // Stores Script schema
  transcript  String?        @db.Text

  // Audio
  audioUrl    String?
  audioBytes  BigInt?
  mimeType    String         @default("audio/mpeg")
  duration    Int?           // Duration in seconds

  // Metadata
  keywords    String[]
  explicit    Boolean        @default(false)
  season      Int?
  episode     Int?

  // Episode type (narrative, interview, debate, adventure)
  type        EpisodeType    @default(NARRATIVE)

  // Status
  status      EpisodeStatus  @default(DRAFT)
  errorMsg    String?        @db.Text

  // Ownership (null for public episodes)
  userId      String?
  user        User?          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Sources/Citations (stored as JSON array)
  sources     Json           @default("[]")

  // Relations
  interview   Interview?
  debate      Debate?
  debateFollowUps DebateFollowUp[]
  adventureNode AdventureNode?

  // Timestamps
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  publishedAt DateTime?

  @@index([status])
  @@index([userId])
  @@index([publishedAt])
  @@index([guid])
  @@index([type])
}

enum EpisodeStatus {
  DRAFT
  GENERATING_OUTLINE
  GENERATING_SCRIPT
  GENERATING_AUDIO
  PROCESSING
  READY
  PUBLISHED
  FAILED
}

enum EpisodeType {
  NARRATIVE      // Original single-voice narration
  INTERVIEW      // Host + guest interview
  DEBATE         // Two-voice debate format
  ADVENTURE      // Choose-your-own-adventure
}

// ============================================================================
// INTERVIEW MODEL
// ============================================================================

model Interview {
  id          String   @id @default(cuid())
  episodeId   String   @unique
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Host details
  hostName    String   @default("The Epoch Host")
  hostVoice   String   @default("onyx")

  // Guest details
  guestName   String   // "Albert Einstein"
  guestRole   String   // "Physicist"
  guestEra    String   // "Early 20th Century"
  guestVoice  String   // "echo"

  // Interview details
  topic       String   // "Theory of Relativity"

  // Content (stored as JSON)
  questions   Json     // Array of prepared questions
  dialogue    Json     // Full interview dialogue

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([episodeId])
  @@index([guestName])
}

// ============================================================================
// DEBATE MODELS
// ============================================================================

model Debate {
  id          String   @id @default(cuid())
  episodeId   String   @unique
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Debate details
  topic       String
  question    String   // "Was Napoleon a tyrant or a reformer?"
  position1   String   // "Tyrant"
  position2   String   // "Reformer"

  // Arguments (stored as JSON)
  argument1   Json     // Full argument for position 1
  argument2   Json     // Full argument for position 2

  // Relations
  votes       DebateVote[]
  followUps   DebateFollowUp[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([episodeId])
  @@index([topic])
}

model DebateVote {
  id          String   @id @default(cuid())
  debateId    String
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // User (optional for anonymous voting)
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Vote details
  position    Int      // 1 or 2
  reasoning   String?  // Optional: why they chose this side

  // Anonymous tracking
  ipAddress   String?  // For anonymous voting
  sessionId   String?  // Track anonymous users

  // Timestamp
  createdAt   DateTime @default(now())

  @@unique([debateId, userId])
  @@unique([debateId, sessionId])
  @@index([debateId])
  @@index([userId])
}

model DebateFollowUp {
  id          String   @id @default(cuid())
  debateId    String
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Follow-up details
  triggerPosition Int  // Follow-up for voters of position 1 or 2
  episodeId   String
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Unlock criteria
  unlockThreshold Int  @default(0) // Min votes needed to unlock

  // Timestamps
  createdAt   DateTime @default(now())

  @@index([debateId])
  @@index([episodeId])
}

// ============================================================================
// ADVENTURE MODELS
// ============================================================================

model Adventure {
  id          String   @id @default(cuid())

  // Basic info
  title       String
  description String   @db.Text
  era         String?

  // Start node reference
  startNodeId String
  startNode   AdventureNode @relation("StartNode", fields: [startNodeId], references: [id], onUpdate: NoAction, onDelete: NoAction)

  // Relations
  nodes       AdventureNode[] @relation("AdventureNodes")
  journeys    UserJourney[]

  // Publishing
  isPublished Boolean  @default(false)

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([isPublished])
}

model AdventureNode {
  id          String   @id @default(cuid())
  adventureId String
  adventure   Adventure @relation("AdventureNodes", fields: [adventureId], references: [id], onDelete: Cascade)

  // Episode link
  episodeId   String   @unique
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Node details
  title       String
  description String   @db.Text
  nodeType    NodeType

  // For decision nodes
  decisionPrompt String?
  choices     Choice[]

  // For ending nodes
  endingType  String?  // "victory", "defeat", "neutral", "bittersweet"

  // Navigation (nodes that link TO this node)
  parentChoices Choice[] @relation("ChoiceDestination")

  // Start node references
  startNodeFor Adventure[] @relation("StartNode")

  // User journey tracking
  currentJourneys UserJourney[] @relation("CurrentNode")

  // Timestamps
  createdAt   DateTime @default(now())

  @@index([adventureId])
  @@index([nodeType])
}

enum NodeType {
  START      // Beginning of adventure
  DECISION   // User makes a choice
  STORY      // Story continuation (no choice)
  ENDING     // Terminal node
}

model Choice {
  id          String   @id @default(cuid())
  nodeId      String
  node        AdventureNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  // Choice details
  text        String   // "Support Caesar"
  description String   @db.Text // Brief explanation of consequences

  // Destination
  nextNodeId  String
  nextNode    AdventureNode @relation("ChoiceDestination", fields: [nextNodeId], references: [id], onDelete: Cascade)

  // Preview
  consequences String  @db.Text // What this choice leads to (for email preview)

  // Timestamps
  createdAt   DateTime @default(now())

  @@index([nodeId])
  @@index([nextNodeId])
}

model UserJourney {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  adventureId String
  adventure   Adventure @relation(fields: [adventureId], references: [id], onDelete: Cascade)

  currentNodeId String
  currentNode   AdventureNode @relation("CurrentNode", fields: [currentNodeId], references: [id])

  // Path history (stored as JSON)
  path        Json     @default("[]") // Array of {nodeId, choiceId, choiceText, timestamp}

  // Completion tracking
  isCompleted Boolean  @default(false)
  completedAt DateTime?

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, adventureId])
  @@index([userId])
  @@index([adventureId])
  @@index([currentNodeId])
}

// ============================================================================
// SHOW METADATA
// ============================================================================

model Show {
  id          String   @id @default(cuid())

  // Basic info
  title       String   @default("Epoch Pod")
  subtitle    String?
  description String   @db.Text

  // Podcast metadata
  language    String   @default("en-us")
  copyright   String?
  author      String   @default("Epoch Pod")
  ownerName   String
  ownerEmail  String

  // Artwork
  imageUrl    String?  // Square artwork (min 1400x1400, max 3000x3000)

  // Categories (iTunes)
  category    String   @default("History")
  subCategory String?

  // Settings
  explicit    Boolean  @default(false)

  // Links
  websiteUrl  String?
  feedUrl     String?

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([id])
}

// ============================================================================
// SUBSCRIPTION & EMAIL MODELS
// ============================================================================

model Subscription {
  id             String         @id @default(cuid())
  userId         String         @unique
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status
  status         SubscriptionStatus @default(ACTIVE)

  // Email settings
  digestCadence  String         @default("weekly") // 'immediate', 'daily', 'weekly', etc.
  lastSentAt     DateTime?
  nextSendAt     DateTime?

  // Timestamps
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  unsubscribedAt DateTime?

  @@index([userId])
  @@index([status])
  @@index([nextSendAt])
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  UNSUBSCRIBED
}

model EmailEvent {
  id         String         @id @default(cuid())

  // Message tracking
  messageId  String
  email      String

  // Event details
  type       EmailEventType
  data       Json?

  // Timestamps
  createdAt  DateTime       @default(now())

  @@index([messageId])
  @@index([email])
  @@index([type])
  @@index([createdAt])
}

enum EmailEventType {
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  COMPLAINED
  UNSUBSCRIBED
}

// ============================================================================
// UNSUBSCRIBE TOKEN MODEL
// ============================================================================

model UnsubscribeToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  email     String

  // Token expiration (30 days default)
  expiresAt DateTime

  // Usage tracking
  usedAt    DateTime?

  // Timestamps
  createdAt DateTime @default(now())

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}
