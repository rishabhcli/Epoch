// Epoch Pod - Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTH MODELS
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  role          UserRole  @default(USER)

  // Preferences (stored as JSON)
  preferences   Json      @default("{\"topics\":[],\"emailCadence\":\"weekly\",\"voiceConfig\":{\"provider\":\"openai\",\"voiceId\":\"alloy\",\"model\":\"tts-1-hd\",\"speed\":1.0},\"episodeDuration\":1200,\"includeTranscripts\":true,\"privateFeedEnabled\":false}")

  // Private RSS feed token
  feedToken     String?   @unique

  // Timestamps
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  emailVerified DateTime?

  // Relations
  accounts      Account[]
  sessions      Session[]
  episodes      Episode[]
  subscription  Subscription?
  debateVotes   DebateVote[]

  @@index([email])
  @@index([feedToken])
}

enum UserRole {
  USER
  ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// EPISODE MODELS
// ============================================================================

model Episode {
  id          String         @id @default(cuid())
  guid        String         @unique @default(cuid())

  // Basic info
  title       String
  subtitle    String?
  description String?

  // Content
  topic       String
  era         String?
  outline     Json?          // Stores Outline schema
  script      Json?          // Stores Script schema
  transcript  String?        @db.Text

  // Audio
  audioUrl    String?
  audioBytes  BigInt?
  mimeType    String         @default("audio/mpeg")
  duration    Int?           // Duration in seconds

  // Metadata
  keywords    String[]
  explicit    Boolean        @default(false)
  season      Int?
  episode     Int?

  // Episode type (narrative, interview, debate, adventure)
  type        EpisodeType    @default(NARRATIVE)

  // Status
  status      EpisodeStatus  @default(DRAFT)
  errorMsg    String?        @db.Text

  // Ownership (null for public episodes)
  userId      String?
  user        User?          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Sources/Citations (stored as JSON array)
  sources     Json           @default("[]")

  // Relations
  interview   Interview?
  debate      Debate?
  debateFollowUps DebateFollowUp[]

  // Timestamps
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  publishedAt DateTime?

  @@index([status])
  @@index([userId])
  @@index([publishedAt])
  @@index([guid])
  @@index([type])
}

enum EpisodeStatus {
  DRAFT
  GENERATING_OUTLINE
  GENERATING_SCRIPT
  GENERATING_AUDIO
  PROCESSING
  READY
  PUBLISHED
  FAILED
}

enum EpisodeType {
  NARRATIVE      // Original single-voice narration
  INTERVIEW      // Host + guest interview
  DEBATE         // Two-voice debate format
  ADVENTURE      // Choose-your-own-adventure
}

// ============================================================================
// INTERVIEW MODEL
// ============================================================================

model Interview {
  id          String   @id @default(cuid())
  episodeId   String   @unique
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Host details
  hostName    String   @default("The Epoch Host")
  hostVoice   String   @default("onyx")

  // Guest details
  guestName   String   // "Albert Einstein"
  guestRole   String   // "Physicist"
  guestEra    String   // "Early 20th Century"
  guestVoice  String   // "echo"

  // Interview details
  topic       String   // "Theory of Relativity"

  // Content (stored as JSON)
  questions   Json     // Array of prepared questions
  dialogue    Json     // Full interview dialogue

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([episodeId])
  @@index([guestName])
}

// ============================================================================
// DEBATE MODELS
// ============================================================================

model Debate {
  id          String   @id @default(cuid())
  episodeId   String   @unique
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Debate details
  topic       String
  question    String   // "Was Napoleon a tyrant or a reformer?"
  position1   String   // "Tyrant"
  position2   String   // "Reformer"

  // Arguments (stored as JSON)
  argument1   Json     // Full argument for position 1
  argument2   Json     // Full argument for position 2

  // Relations
  votes       DebateVote[]
  followUps   DebateFollowUp[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([episodeId])
  @@index([topic])
}

model DebateVote {
  id          String   @id @default(cuid())
  debateId    String
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // User (optional for anonymous voting)
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Vote details
  position    Int      // 1 or 2
  reasoning   String?  // Optional: why they chose this side

  // Anonymous tracking
  ipAddress   String?  // For anonymous voting
  sessionId   String?  // Track anonymous users

  // Timestamp
  createdAt   DateTime @default(now())

  @@unique([debateId, userId])
  @@unique([debateId, sessionId])
  @@index([debateId])
  @@index([userId])
}

model DebateFollowUp {
  id          String   @id @default(cuid())
  debateId    String
  debate      Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Follow-up details
  triggerPosition Int  // Follow-up for voters of position 1 or 2
  episodeId   String
  episode     Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  // Unlock criteria
  unlockThreshold Int  @default(0) // Min votes needed to unlock

  // Timestamps
  createdAt   DateTime @default(now())

  @@index([debateId])
  @@index([episodeId])
}

// ============================================================================
// SHOW METADATA
// ============================================================================

model Show {
  id          String   @id @default(cuid())

  // Basic info
  title       String   @default("Epoch Pod")
  subtitle    String?
  description String   @db.Text

  // Podcast metadata
  language    String   @default("en-us")
  copyright   String?
  author      String   @default("Epoch Pod")
  ownerName   String
  ownerEmail  String

  // Artwork
  imageUrl    String?  // Square artwork (min 1400x1400, max 3000x3000)

  // Categories (iTunes)
  category    String   @default("History")
  subCategory String?

  // Settings
  explicit    Boolean  @default(false)

  // Links
  websiteUrl  String?
  feedUrl     String?

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([id])
}

// ============================================================================
// SUBSCRIPTION & EMAIL MODELS
// ============================================================================

model Subscription {
  id             String         @id @default(cuid())
  userId         String         @unique
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Status
  status         SubscriptionStatus @default(ACTIVE)

  // Email settings
  digestCadence  String         @default("weekly") // 'immediate', 'daily', 'weekly', etc.
  lastSentAt     DateTime?
  nextSendAt     DateTime?

  // Timestamps
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  unsubscribedAt DateTime?

  @@index([userId])
  @@index([status])
  @@index([nextSendAt])
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  UNSUBSCRIBED
}

model EmailEvent {
  id         String         @id @default(cuid())

  // Message tracking
  messageId  String
  email      String

  // Event details
  type       EmailEventType
  data       Json?

  // Timestamps
  createdAt  DateTime       @default(now())

  @@index([messageId])
  @@index([email])
  @@index([type])
  @@index([createdAt])
}

enum EmailEventType {
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  COMPLAINED
  UNSUBSCRIBED
}
